<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PlusLab Generator</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    
    <!-- Babel (für JSX) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        ::-webkit-scrollbar { width: 6px; height: 6px; }
        ::-webkit-scrollbar-track { background: #111827; }
        ::-webkit-scrollbar-thumb { background: #374151; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #4B5563; }
        body { margin: 0; overflow: hidden; background: #000; }
        
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        
        .no-select { user-select: none; -webkit-user-select: none; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useRef, useMemo, useEffect, memo, forwardRef, useCallback } = React;
        
        // --- ICONS ---
        const IconBase = ({ children, size = 12, className = "" }) => (
            <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{children}</svg>
        );
        const Download = (p) => (<IconBase {...p} size={14}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></IconBase>);
        const Maximize = (p) => (<IconBase {...p}><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"/></IconBase>);
        const Grid = (p) => (<IconBase {...p}><rect width="7" height="7" x="3" y="3" rx="1"/><rect width="7" height="7" x="14" y="3" rx="1"/><rect width="7" height="7" x="14" y="14" rx="1"/><rect width="7" height="7" x="3" y="14" rx="1"/></IconBase>);
        const Activity = (p) => (<IconBase {...p}><path d="M22 12h-4l-3 9L9 3l-3 9H2"/></IconBase>);
        const Layers = (p) => (<IconBase {...p}><path d="m12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83Z"/><path d="m22 17.65-9.17 4.16a2 2 0 0 1-1.66 0L2 17.65"/><path d="m22 12.65-9.17 4.16a2 2 0 0 1-1.66 0L2 12.65"/></IconBase>);
        const Palette = (p) => (<IconBase {...p}><circle cx="13.5" cy="6.5" r=".5"/><circle cx="17.5" cy="10.5" r=".5"/><circle cx="8.5" cy="7.5" r=".5"/><circle cx="6.5" cy="12.5" r=".5"/><path d="M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10c.926 0 1.648-.746 1.648-1.688 0-.437-.18-.835-.437-1.125-.29-.289-.438-.652-.438-1.125a1.64 1.64 0 0 1 1.668-1.668h1.996c3.051 0 5.555-2.503 5.555-5.554C21.965 6.012 17.461 2 12 2z"/></IconBase>);
        const Shuffle = (p) => (<IconBase {...p}><path d="M2 18h1.4c1.3 0 2.5-.6 3.3-1.7l10.6-12.6c.7-1 1.8-1.7 3-1.7H22"/><path d="m16 2 5 5-5 5"/><path d="M2 6h1.4c1.3 0 2.5.6 3.3 1.7l1.6 1.9"/><path d="M18.7 13.3c.8 1.1 2 1.7 3.3 1.7H22"/><path d="m16 22 5-5-5-5"/></IconBase>);
        const TrendingUp = (p) => (<IconBase {...p}><polyline points="22 7 13.5 15.5 8.5 10.5 2 17"/><polyline points="16 7 22 7 22 13"/></IconBase>);
        const RotateCcw = (p) => (<IconBase {...p}><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></IconBase>);
        const Brush = (p) => (<IconBase {...p}><path d="m9.06 11.9 8.07-8.06a2.85 2.85 0 1 1 4.03 4.03l-8.06 8.08"/><path d="M7.07 14.94c-1.66 0-3 1.35-3 3.02 0 1.33-2.5 1.52-2.5 2.24 0 .46.62.8.62.8"/><path d="M14.26 17.74c-1.66 0-3 1.35-3 3.02 0 1.33-2.5 1.52-2.5 2.24 0 .46.62.8.62.8"/></IconBase>);
        const Plus = (p) => (<IconBase {...p}><path d="M5 12h14"/><path d="M12 5v14"/></IconBase>);
        const Minus = (p) => (<IconBase {...p}><path d="M5 12h14"/></IconBase>);
        const Cloud = (p) => (<IconBase {...p}><path d="M17.5 19c0-1.7-1.3-3-3-3h-11C1.6 16 0 14.4 0 12.5S1.6 9 3.5 9c.2 0 .5 0 .7.1C5.3 5.6 8.4 3 12 3c3.9 0 7.1 2.9 7.5 6.7 2.3.6 4 2.6 4 5.1 0 2.9-2.4 5.2-5.3 5.2h-1.7z"/></IconBase>);

        // --- COMPONENTS ---

        const EditableValue = memo(({ value, onChange, min, max, unit }) => {
            const [isEditing, setIsEditing] = useState(false);
            const [tempValue, setTempValue] = useState(value);
            const inputRef = useRef(null);

            useEffect(() => {
                if (isEditing && inputRef.current) {
                    inputRef.current.focus();
                    inputRef.current.select();
                }
            }, [isEditing]);

            useEffect(() => {
                if (!isEditing && value !== undefined) setTempValue(value);
            }, [value, isEditing]);

            const commit = () => {
                let val = parseFloat(tempValue);
                if (isNaN(val)) val = value;
                val = Math.round(val * 100) / 100;
                if (min !== undefined && val < min) val = min;
                if (max !== undefined && val > max) val = max;
                onChange(val);
                setIsEditing(false);
            };

            const handleKeyDown = (e) => {
                if (e.key === 'Enter') commit();
                if (e.key === 'Escape') { setTempValue(value); setIsEditing(false); }
            };

            if (isEditing) {
                return <input ref={inputRef} type="number" value={tempValue} onChange={(e) => setTempValue(e.target.value)} onBlur={commit} onKeyDown={handleKeyDown} className="w-12 h-4 text-[10px] bg-gray-700 text-white rounded px-0 border border-blue-500 outline-none text-right overflow-hidden m-0 leading-none select-text" />;
            }
            return <span onClick={() => setIsEditing(true)} className="text-[10px] text-gray-400 font-mono hover:text-blue-300 cursor-pointer transition-colors min-w-[30px] text-right inline-block" title="Bearbeiten">{typeof value === 'number' ? value.toFixed(2) : "0.00"}{unit}</span>;
        });

        const Slider = memo(({ label, value, onChange, min, max, step = 0.01, unit = "", highlight = false }) => {
            const handleChange = (e) => {
                const raw = parseFloat(e.target.value);
                const rounded = Math.round(raw * 100) / 100;
                onChange(rounded);
            };

            return (
                <div className="flex items-center gap-2 mb-1 h-6">
                    <label className={`text-[10px] font-medium w-24 shrink-0 truncate ${highlight ? 'text-blue-300' : 'text-gray-400'}`} title={label}>{label}</label>
                    <div className="flex-grow flex items-center relative">
                        <input type="range" min={min} max={max} step={step} value={value} onChange={handleChange} className={`w-full h-1 rounded-lg appearance-none cursor-pointer focus:outline-none focus:ring-1 focus:ring-blue-500/50 ${highlight ? 'bg-blue-900 accent-blue-400' : 'bg-gray-700 accent-blue-500 hover:accent-blue-400'}`} />
                    </div>
                    <div className="w-10 flex justify-end shrink-0">
                        <EditableValue value={value} onChange={onChange} min={min} max={max} unit={unit} />
                    </div>
                </div>
            );
        });

        const ColorPicker = memo(({ label, value, onChange }) => {
            const [isEditing, setIsEditing] = useState(false);
            const [tempValue, setTempValue] = useState(value);
            const inputRef = useRef(null);

            useEffect(() => { if (isEditing && inputRef.current) { inputRef.current.focus(); inputRef.current.select(); } }, [isEditing]);
            useEffect(() => { setTempValue(value); }, [value]);

            const commit = () => {
                let val = tempValue.trim();
                if (/^[0-9A-Fa-f]{6}$/.test(val)) val = '#' + val;
                if (/^#[0-9A-Fa-f]{6}$/.test(val)) onChange(val); else setTempValue(value);
                setIsEditing(false);
            };

            const handleKeyDown = (e) => { if (e.key === 'Enter') commit(); if (e.key === 'Escape') { setTempValue(value); setIsEditing(false); } };
            const safeColor = /^#[0-9A-Fa-f]{6}$/.test(value) ? value : '#000000';

            return (
                <div className="flex items-center justify-between py-0.5 h-6">
                    <label className="text-[10px] font-medium text-gray-400 w-24 shrink-0 truncate">{label}</label>
                    <div className="flex items-center gap-2 flex-grow justify-end">
                        {isEditing ? <input ref={inputRef} type="text" value={tempValue} onChange={(e) => setTempValue(e.target.value)} onBlur={commit} onKeyDown={handleKeyDown} className="w-14 h-4 text-[10px] bg-gray-700 text-white rounded px-1 border border-blue-500 outline-none font-mono uppercase select-text" /> 
                        : <span className="text-[10px] font-mono text-gray-500 uppercase cursor-pointer hover:text-white transition-colors" onClick={() => setIsEditing(true)}>{value}</span>}
                        <input type="color" value={safeColor} onChange={(e) => onChange(e.target.value)} className="w-8 h-4 rounded cursor-pointer bg-transparent border-0 p-0" />
                    </div>
                </div>
            );
        });

        const SliderGroup = ({ title, icon: Icon, children }) => (
            <div className="mb-3 border-b border-gray-800 pb-2 last:border-0">
                <h3 className="text-[10px] font-bold text-gray-500 uppercase tracking-wider mb-2 flex items-center gap-2">
                    {Icon && <Icon className="text-blue-500" />} {title}
                </h3>
                <div className="pl-1">{children}</div>
            </div>
        );

        // --- HELPER: Pseudo Random für Noise ---
        // Deterministic random based on x/y index
        const pseudoRandom = (x, y) => {
            return Math.sin(x * 12.9898 + y * 78.233) * 43758.5453 - Math.floor(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453);
        };

        // --- CANVAS AREA ---
        const CanvasArea = memo(forwardRef(({ renderConfig, dimensions, paintingState, onPaintInteraction }, ref) => {
            const { 
                size, formScale, thickness, // Form Params
                scale, gapX, gapY, // Grid (Rotation removed from here)
                rowOffset, waveAmp, waveFreq, posNoiseAmp, // Rhythm (posNoiseAmp added)
                gradScaleY, gradRotateY, gradAngle, noiseAmp, noiseFreq, // Dynamic
                fillColor 
            } = renderConfig;
            const { isPainting, brushSize, paintTool, modifications } = paintingState;

            // 1. Grid Calculation (ZENTRIERT)
            const gridData = useMemo(() => {
                const elementSize = (size * formScale) * scale;
                const stepX = elementSize + gapX;
                const stepY = elementSize + gapY;

                if (stepX < 5 || stepY < 5) return { items: [], centerX: 0, centerY: 0, stepX: 1, stepY: 1 };

                // Calculate how many items fit from center to edge
                const halfWidth = dimensions.width / 2;
                const halfHeight = dimensions.height / 2;
                
                // We add a buffer to ensure we cover the screen even when rotated or wave-shifted
                // Extra margin depends on wave amplitude
                const waveBuffer = Math.abs(waveAmp) + 100; // Pixel buffer
                
                const countX = Math.ceil((halfWidth + 100) / stepX); 
                const countY = Math.ceil((halfHeight + waveBuffer) / stepY);

                // Total columns/rows (must be odd to have a perfect center item)
                const cols = countX * 2 + 1;
                const rows = countY * 2 + 1;

                const totalItems = cols * rows;
                // Limit items to prevent crashes, but keep high enough for typical usage
                // If zoom is very small (scale 0.2), items count increases.
                const MAX_ITEMS = 5000; 
                
                // If too many items, we might clip the outer edges, but with min-scale 0.2 it should be mostly fine
                const effectiveRows = totalItems > MAX_ITEMS ? Math.floor(MAX_ITEMS / cols) : rows;
                const effectiveCols = cols;

                return { 
                    stepX, stepY, 
                    halfCols: Math.floor(effectiveCols / 2), 
                    halfRows: Math.floor(effectiveRows / 2),
                    centerX: halfWidth, 
                    centerY: halfHeight 
                };
            }, [renderConfig, dimensions]);

            // 2. Generate Items
            const gridItems = useMemo(() => {
                const { stepX, stepY, halfCols, halfRows, centerX, centerY } = gridData;
                if (halfCols === 0) return [];

                const items = [];
                const maxDist = Math.sqrt(Math.pow(dimensions.width/2, 2) + Math.pow(dimensions.height/2, 2)) || 1;

                // Iterate relative to center (c=0, r=0 is center)
                for (let r = -halfRows; r <= halfRows; r++) {
                    for (let c = -halfCols; c <= halfCols; c++) {
                        
                        // Base Position (Center + Grid Step)
                        let x = centerX + (c * stepX);
                        let y = centerY + (r * stepY);

                        // 1. Rhythmus: Row Offset
                        if (r % 2 !== 0) x += rowOffset; // Changed modulo check to work with negative numbers correctly logically
                        
                        // 2. Rhythmus: Wave
                        // Use 'c' for wave phase to keep it consistent across rows
                        y += Math.sin(c * waveFreq) * waveAmp;

                        // 3. Rhythmus: Position Noise (Jitter)
                        if (posNoiseAmp > 0) {
                            const jitterX = (pseudoRandom(c, r) - 0.5) * 2 * posNoiseAmp;
                            const jitterY = (pseudoRandom(r, c) - 0.5) * 2 * posNoiseAmp; // swapped seeds
                            x += jitterX;
                            y += jitterY;
                        }

                        // Center-based Calculations for Dynamics
                        // Recalculate relative pos after displacements for effects? 
                        // Usually effects are based on grid pos. Let's use current x/y relative to center.
                        const dx = x - centerX;
                        const dy = y - centerY;
                        const dist = Math.sqrt(dx*dx + dy*dy);
                        const progress = Math.min(dist / maxDist, 1);
                        const angleRad = Math.atan2(dy, dx); 
                        
                        // Noise Cloud Calculation
                        // Frequency scales the input to the noise function
                        const nVal = (Math.sin(c * noiseFreq) + Math.cos(r * noiseFreq * 0.85) + Math.sin((c*0.5 + r*0.3) * noiseFreq));
                        
                        // 1. Scale Effects
                        let currentScale = scale * formScale;
                        
                        // Distance Gradient
                        currentScale *= (1 + progress * gradScaleY * 2);
                        
                        // Noise Cloud Scale
                        // nVal varies roughly -2 to 2. We normalize/clamp it for the amp effect
                        currentScale *= (1 + nVal * 0.5 * noiseAmp);

                        if (currentScale < 0.1) currentScale = 0.1;
                        
                        // 2. Rotation Effects
                        let currentRotation = 0; // Base rotation removed from grid settings
                        currentRotation += (progress * gradRotateY);
                        currentRotation += (angleRad * (gradAngle || 0));

                        // Apply Paint Modifications
                        const modKey = `${r}-${c}`;
                        if (modifications[modKey]) {
                            currentScale += modifications[modKey];
                            if (currentScale < 0.1) currentScale = 0.1;
                        }

                        // Only render if within reasonable bounds (optimization)
                        // Add buffer for scale
                        if (x < -200 || x > dimensions.width + 200 || y < -200 || y > dimensions.height + 200) continue;

                        const transformStr = `translate(${x.toFixed(2)}, ${y.toFixed(2)}) rotate(${currentRotation.toFixed(2)}) scale(${currentScale.toFixed(2)})`;
                        items.push(<use key={modKey} href="#plus-shape" transform={transformStr} fill={fillColor} />);
                    }
                }
                return items;
            }, [gridData, renderConfig, dimensions, modifications]);

            // 3. Plus Shape Def
            const plusPath = useMemo(() => {
                const s = size / 2;
                const t = thickness / 2;
                return `M ${-t} ${-s} h ${thickness} v ${size} h -${thickness} Z M ${-s} ${-t} h ${size} v ${thickness} h -${size} Z`;
            }, [size, thickness]);

            // 4. Paint Interaction
            const handleInteraction = (e) => {
                if (!isPainting || (e.buttons !== 1 && e.type !== 'click')) return;
                
                const rect = e.currentTarget.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                const { stepX, stepY, halfCols, halfRows, centerX, centerY } = gridData;
                
                // Optimization: Estimate indices near mouse
                // Reverse the grid transform logic roughly
                const estC = Math.round((mouseX - centerX) / stepX);
                const estR = Math.round((mouseY - centerY) / stepY);
                
                const rangeX = Math.ceil(brushSize / stepX) + 2;
                const rangeY = Math.ceil(brushSize / stepY) + 2;

                const newMods = {};
                let hasChanges = false;

                for (let r = Math.max(-halfRows, estR - rangeY); r <= Math.min(halfRows, estR + rangeY); r++) {
                    for (let c = Math.max(-halfCols, estC - rangeX); c <= Math.min(halfCols, estC + rangeX); c++) {
                        
                        // Exact position recalculation for collision
                        let x = centerX + (c * stepX);
                        let y = centerY + (r * stepY);
                        if (r % 2 !== 0) x += rowOffset;
                        y += Math.sin(c * waveFreq) * waveAmp;
                        
                        if (posNoiseAmp > 0) {
                            x += (pseudoRandom(c, r) - 0.5) * 2 * posNoiseAmp;
                            y += (pseudoRandom(r, c) - 0.5) * 2 * posNoiseAmp;
                        }

                        const dist = Math.sqrt(Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2));
                        
                        if (dist <= brushSize / 2) {
                            const key = `${r}-${c}`;
                            const currentMod = modifications[key] || 0;
                            const delta = paintTool === 'plus' ? 0.05 : -0.05;
                            newMods[key] = currentMod + delta;
                            hasChanges = true;
                        }
                    }
                }

                if (hasChanges) {
                    onPaintInteraction(newMods);
                }
            };

            const bgFill = renderConfig.useBgGradient ? "url(#bg-gradient)" : renderConfig.bgColor;

            return (
                <div 
                    className={`w-full h-full relative overflow-hidden ${isPainting ? 'cursor-none' : 'cursor-crosshair'}`}
                    onMouseDown={handleInteraction}
                    onMouseMove={handleInteraction}
                    onClick={handleInteraction}
                >
                    <svg ref={ref} id="main-canvas" width="100%" height="100%" viewBox={`0 0 ${dimensions.width} ${dimensions.height}`} preserveAspectRatio="xMidYMid slice">
                        <defs>
                            <path id="plus-shape" d={plusPath} />
                            {renderConfig.useBgGradient && (
                                <linearGradient id="bg-gradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                    <stop offset="0%" stopColor={renderConfig.bgColor} />
                                    <stop offset="100%" stopColor={renderConfig.bgColor2} />
                                </linearGradient>
                            )}
                        </defs>
                        <rect id="bg-rect" width="100%" height="100%" fill={bgFill} />
                        <g>{gridItems}</g>
                    </svg>
                    {isPainting && (
                        <div 
                            className="pointer-events-none absolute rounded-full border-2 border-white/50 bg-white/10 mix-blend-difference"
                            style={{
                                width: brushSize,
                                height: brushSize,
                                left: 0, top: 0,
                                transform: 'translate(-50%, -50%)', 
                            }}
                            ref={(el) => {
                                if(el) {
                                    const updatePos = (e) => {
                                        const rect = el.parentElement.getBoundingClientRect();
                                        el.style.left = (e.clientX - rect.left) + 'px';
                                        el.style.top = (e.clientY - rect.top) + 'px';
                                    };
                                    el.parentElement.addEventListener('mousemove', updatePos);
                                }
                            }}
                        />
                    )}
                </div>
            );
        }));

        // --- APP ---
        function App() {
            // UI State
            const [size, setSize] = useState(60);       
            const [thickness, setThickness] = useState(15); 
            const [formScale, setFormScale] = useState(1); 

            const [bgColor, setBgColor] = useState('#040066');
            const [bgColor2, setBgColor2] = useState('#040066'); 
            const [useBgGradient, setUseBgGradient] = useState(false); 
            const [fillColor, setFillColor] = useState('#ffffff');
            const [scale, setScale] = useState(0.8);
            const [gapX, setGapX] = useState(20);
            const [gapY, setGapY] = useState(20);
            // rotation removed
            const [rowOffset, setRowOffset] = useState(0); 
            const [waveAmp, setWaveAmp] = useState(0);     
            const [waveFreq, setWaveFreq] = useState(0.5); 
            const [posNoiseAmp, setPosNoiseAmp] = useState(0); // NEW
            
            // Dynamics
            const [gradScaleY, setGradScaleY] = useState(0); 
            const [gradRotateY, setGradRotateY] = useState(0);
            const [gradAngle, setGradAngle] = useState(0); 
            const [noiseAmp, setNoiseAmp] = useState(0);   
            const [noiseFreq, setNoiseFreq] = useState(0.2); 

            const [exportBg, setExportBg] = useState(true);

            // Painting
            const [paintMode, setPaintMode] = useState(false);
            const [brushSize, setBrushSize] = useState(100);
            const [paintTool, setPaintTool] = useState('plus');
            const [paintModifications, setPaintModifications] = useState({}); 

            const [renderConfig, setRenderConfig] = useState({
                size, formScale, thickness, bgColor, bgColor2, useBgGradient, fillColor, scale, gapX, gapY, /*rotation*/ rowOffset, waveAmp, waveFreq, posNoiseAmp, gradScaleY, gradRotateY, gradAngle, noiseAmp, noiseFreq
            });

            const containerRef = useRef(null);
            const svgRef = useRef(null);
            const [dimensions, setDimensions] = useState({ width: 1200, height: 800 });

            useEffect(() => {
                if (!containerRef.current) return;
                const updateSize = () => setDimensions({ width: containerRef.current.offsetWidth, height: containerRef.current.offsetHeight });
                updateSize();
                window.addEventListener('resize', updateSize);
                return () => window.removeEventListener('resize', updateSize);
            }, []);

            useEffect(() => {
                const h = setTimeout(() => {
                    setRenderConfig({ size, formScale, thickness, bgColor, bgColor2, useBgGradient, fillColor, scale, gapX, gapY, /*rotation*/ rowOffset, waveAmp, waveFreq, posNoiseAmp, gradScaleY, gradRotateY, gradAngle, noiseAmp, noiseFreq });
                }, 40);
                return () => clearTimeout(h);
            }, [size, formScale, thickness, bgColor, bgColor2, useBgGradient, fillColor, scale, gapX, gapY, /*rotation*/ rowOffset, waveAmp, waveFreq, posNoiseAmp, gradScaleY, gradRotateY, gradAngle, noiseAmp, noiseFreq]);

            const handlePaintInteraction = useCallback((newMods) => {
                setPaintModifications(prev => ({ ...prev, ...newMods }));
            }, []);

            const resetPainting = () => setPaintModifications({});

            const reset = () => {
                setSize(60); setThickness(15); setFormScale(1);
                setBgColor('#040066'); setBgColor2('#040066'); setUseBgGradient(false); setFillColor('#ffffff');
                setScale(0.8); setGapX(20); setGapY(20); /*setRotation(0);*/ setRowOffset(0); setWaveAmp(0); setWaveFreq(0.5); setPosNoiseAmp(0);
                setGradScaleY(0); setGradRotateY(0); setGradAngle(0); setNoiseAmp(0); setNoiseFreq(0.2);
                setExportBg(true); setPaintModifications({});
            };
            const randomize = () => {
                const r = (min, max) => Math.round((Math.random() * (max - min) + min) * 100) / 100;
                const rColor = () => '#' + Math.floor(Math.random()*16777215).toString(16).padStart(6, '0');
                setSize(r(20, 100)); setThickness(r(5, 40)); setFormScale(r(0.5, 1.5));
                setScale(r(0.3, 1.2)); setGapX(r(0, 80)); setGapY(r(0, 80));
                /*setRotation(Math.random()>0.7 ? r(0, 90) : 0);*/ setRowOffset(Math.random()>0.5 ? r(-50, 50) : 0);
                setWaveAmp(Math.random()>0.7 ? r(0, 50) : 0); setWaveFreq(r(0.1, 0.8)); setPosNoiseAmp(Math.random()>0.7 ? r(0, 50) : 0);
                setGradScaleY(Math.random()>0.6 ? r(-1, 1) : 0); setGradRotateY(Math.random()>0.8 ? r(0, 180) : 0);
                setGradAngle(Math.random()>0.8 ? r(0, 180) : 0); setNoiseAmp(Math.random()>0.7 ? r(0, 1) : 0);
                setBgColor(rColor()); setBgColor2(rColor()); setUseBgGradient(Math.random()>0.5); setFillColor(rColor());
                setPaintModifications({});
            };
            
            const handleExport = () => {
                if (!svgRef.current) return;
                const clone = svgRef.current.cloneNode(true);
                if (!exportBg) { const bg = clone.querySelector('#bg-rect'); if (bg) bg.remove(); }
                const blob = new Blob([new XMLSerializer().serializeToString(clone)], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = `PlusLab_${new Date().toISOString().slice(0, 10)}.svg`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            };

            const previewPath = useMemo(() => {
                const s = (size * formScale) / 2;
                const t = (thickness * formScale) / 2;
                return `M ${-t} ${-s} h ${thickness*formScale} v ${size*formScale} h -${thickness*formScale} Z M ${-s} ${-t} h ${size*formScale} v ${thickness*formScale} h -${size*formScale} Z`;
            }, [size, thickness, formScale]);

            const bgStyle = useBgGradient ? `linear-gradient(to bottom, ${bgColor}, ${bgColor2})` : bgColor;

            return (
                <div className="flex h-screen w-full bg-gray-950 text-white overflow-hidden font-sans selection:bg-blue-500/30 select-none">
                    <aside className="w-[400px] flex-shrink-0 h-full overflow-y-auto border-r border-gray-800 bg-gray-900 flex flex-col shadow-2xl z-20">
                        <div className="p-4 pb-2 flex justify-between items-start border-b border-gray-800/50">
                            <h1 className="text-lg font-bold text-white mb-0">PlusLab</h1>
                            <div className="flex gap-2">
                                <button onClick={reset} className="p-1.5 bg-gray-700 hover:bg-gray-600 rounded-md shadow-lg active:scale-95" title="Reset"><RotateCcw size={14} /></button>
                                <button onClick={randomize} className="p-1.5 bg-blue-600 hover:bg-blue-500 rounded-md shadow-lg active:scale-95 flex items-center gap-1 text-xs font-medium"><Shuffle size={14} /> Random</button>
                            </div>
                        </div>

                        <div className="px-4 py-4 bg-gray-900/50 flex justify-center">
                            <div className="w-full max-w-[200px] aspect-square rounded border border-gray-700 flex items-center justify-center relative overflow-hidden shadow-xl" style={{ background: bgStyle }}>
                                <svg width="60" height="60" viewBox="-100 -100 200 200" className="drop-shadow-lg"><path d={previewPath} fill={fillColor} /></svg>
                            </div>
                        </div>

                        <div className="flex-grow px-4 py-2">
                            <SliderGroup title="Farben & Hintergrund" icon={Palette}>
                                <ColorPicker label="Start-Farbe" value={bgColor} onChange={setBgColor} />
                                {useBgGradient && <ColorPicker label="End-Farbe" value={bgColor2} onChange={setBgColor2} />}
                                <div className="flex items-center gap-2 mt-1 mb-1 h-6">
                                    <label className="text-[10px] text-gray-400 w-24 shrink-0">Verlauf</label>
                                    <div className="flex items-center gap-2"><input type="checkbox" checked={useBgGradient} onChange={(e) => setUseBgGradient(e.target.checked)} className="accent-blue-500 h-3 w-3" /><label className="text-[10px] text-gray-500 cursor-pointer">Aktivieren</label></div>
                                </div>
                                <div className="h-px bg-gray-800 my-1"></div>
                                <ColorPicker label="Form Farbe" value={fillColor} onChange={setFillColor} />
                            </SliderGroup>

                            <SliderGroup title="Form Parameter" icon={Layers}>
                                <Slider label="Skalierung (Element)" value={formScale} onChange={setFormScale} min={0.1} max={3} step={0.1} />
                                <Slider label="Armlänge" value={size} onChange={setSize} min={10} max={200} step={0.1} />
                                <Slider label="Dicke" value={thickness} onChange={setThickness} min={1} max={50} step={0.1} />
                            </SliderGroup>

                            <SliderGroup title="Rapport Grid" icon={Grid}>
                                <Slider label="Zoom" value={scale} onChange={setScale} min={0.2} max={2.5} step={0.01} />
                                <Slider label="Abstand X" value={gapX} onChange={setGapX} min={0} max={150} step={0.1} />
                                <Slider label="Abstand Y" value={gapY} onChange={setGapY} min={0} max={150} step={0.1} />
                                {/* Rotation entfernt */}
                            </SliderGroup>

                            <SliderGroup title="Rhythmus & Wellen" icon={Activity}>
                                <Slider label="Versatz (2. Zeile)" value={rowOffset} onChange={setRowOffset} min={-100} max={100} step={0.1} />
                                <Slider label="Welle Amplitude" value={waveAmp} onChange={setWaveAmp} min={0} max={100} step={0.1} />
                                <Slider label="Welle Frequenz" value={waveFreq} onChange={setWaveFreq} min={0.05} max={1.5} step={0.01} />
                                <div className="h-px bg-blue-900/30 my-2"></div>
                                <Slider label="Position Noise" value={posNoiseAmp} onChange={setPosNoiseAmp} min={0} max={100} step={0.1} highlight={true} />
                            </SliderGroup>

                            <SliderGroup title="Verläufe & Dynamik (Zentriert)" icon={TrendingUp}>
                                <div className="bg-gradient-to-b from-blue-900/10 to-blue-900/30 p-2 rounded border border-blue-900/30">
                                    <p className="text-[9px] text-blue-300 mb-2 opacity-70">Zentrum -> Außen</p>
                                    <Slider label="Verlauf Skalierung" value={gradScaleY} onChange={setGradScaleY} min={-1.5} max={1.5} step={0.01} highlight={true} />
                                    <Slider label="Verlauf Rotation" value={gradRotateY} onChange={setGradRotateY} min={-180} max={180} unit="°" step={0.1} highlight={true} />
                                    <div className="h-px bg-blue-900/30 my-2"></div>
                                    <Slider label="Winkel -> Rotation" value={gradAngle} onChange={setGradAngle} min={-180} max={180} unit="°" step={0.1} highlight={true} />
                                    <div className="h-px bg-blue-900/30 my-2"></div>
                                    <div className="flex items-center gap-2 mb-1"><Cloud size={10} className="text-blue-400"/><span className="text-[9px] text-blue-300">Noise (Wolken)</span></div>
                                    <Slider label="Noise Stärke" value={noiseAmp} onChange={setNoiseAmp} min={0} max={2} step={0.01} highlight={true} />
                                    <Slider label="Noise Skalierung (Frequenz)" value={noiseFreq} onChange={setNoiseFreq} min={0.01} max={1} step={0.01} highlight={true} />
                                </div>
                            </SliderGroup>

                            {/* MAL-MODUS */}
                            <SliderGroup title="Mal-Modus (Experimentell)" icon={Brush}>
                                <div className="bg-gray-800/50 p-2 rounded border border-gray-700 space-y-3">
                                    <div className="flex items-center justify-between">
                                        <label className="text-[10px] text-gray-400">Aktivieren</label>
                                        <div className="flex items-center gap-2">
                                            <input type="checkbox" checked={paintMode} onChange={(e) => setPaintMode(e.target.checked)} className="accent-blue-500 h-4 w-4 cursor-pointer" />
                                            <span className={`text-[10px] font-bold ${paintMode ? 'text-blue-400' : 'text-gray-600'}`}>{paintMode ? "AN" : "AUS"}</span>
                                        </div>
                                    </div>
                                    
                                    {paintMode && (
                                        <>
                                            <Slider label="Durchmesser" value={brushSize} onChange={setBrushSize} min={20} max={300} step={1} unit="px" />
                                            
                                            <div className="flex gap-2 pt-1">
                                                <button 
                                                    onClick={() => setPaintTool('plus')}
                                                    className={`flex-1 py-1.5 rounded text-[10px] font-bold flex items-center justify-center gap-1 border ${paintTool === 'plus' ? 'bg-blue-600 border-blue-500 text-white' : 'bg-gray-700 border-gray-600 text-gray-400'}`}
                                                >
                                                    <Plus size={10} /> Vergrößern
                                                </button>
                                                <button 
                                                    onClick={() => setPaintTool('minus')}
                                                    className={`flex-1 py-1.5 rounded text-[10px] font-bold flex items-center justify-center gap-1 border ${paintTool === 'minus' ? 'bg-blue-600 border-blue-500 text-white' : 'bg-gray-700 border-gray-600 text-gray-400'}`}
                                                >
                                                    <Minus size={10} /> Verkleinern
                                                </button>
                                            </div>
                                            <button 
                                                onClick={resetPainting}
                                                className="w-full py-1 bg-red-900/30 hover:bg-red-900/50 border border-red-900/50 text-red-200 rounded text-[10px] mt-1"
                                            >
                                                Malen zurücksetzen
                                            </button>
                                        </>
                                    )}
                                </div>
                            </SliderGroup>
                        </div>

                        <div className="p-4 mt-auto bg-gray-900 border-t border-gray-800 flex items-center gap-3">
                            <button onClick={handleExport} className="flex-grow bg-white text-black hover:bg-gray-200 py-2 px-4 rounded font-bold text-xs flex items-center justify-center gap-2 transition-all active:scale-95"><Download size={14} /> SVG SPEICHERN</button>
                            <div className="flex items-center gap-2">
                                <input type="checkbox" id="exportBgCheck" checked={exportBg} onChange={(e) => setExportBg(e.target.checked)} className="accent-blue-500 h-4 w-4 cursor-pointer" />
                                <label htmlFor="exportBgCheck" className="text-[10px] text-gray-400 cursor-pointer select-none leading-tight w-16">Hintergrund exportieren</label>
                            </div>
                        </div>
                    </aside>

                    <main ref={containerRef} className="flex-1 h-full relative overflow-hidden" style={{ background: bgStyle }}>
                         <CanvasArea 
                            ref={svgRef} 
                            renderConfig={renderConfig} 
                            dimensions={dimensions}
                            paintingState={{ isPainting: paintMode, brushSize, paintTool, modifications: paintModifications }}
                            onPaintInteraction={handlePaintInteraction}
                         />
                         <div className="absolute top-4 right-4 pointer-events-none mix-blend-difference opacity-50"><div className="text-xs font-mono text-white">{dimensions.width} x {dimensions.height}px</div></div>
                    </main>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
